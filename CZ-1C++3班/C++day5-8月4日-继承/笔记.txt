8.4号（深浅拷贝  内存泄漏   new和delete的特点与重载    继承的特点  ）

模板类 不要使用对应的cpp  直接在hpp里面实现函数功能

参数是同时传入的，没有先后顺序（尤其在对象的this指针时候要注意）

浅拷贝 就是 值拷贝
深拷贝 就是 出现了动态数组
深拷贝 必须实现 拷贝构造和赋值运算符重载   
写时拷贝：在进行修改的时候 开辟一个新空间 赋值 再修改
                  其中计数器时写时拷贝的精髓
需要对值修改的时候进行深拷贝即写时拷贝

operator new 只是重载了new的申请空间和报错的功能   而剩下的没有重载   即void* 转换等
同理 operator delete 也只是 重载了释放和报错的功能  调用析构的没有重载
new的重载参数时（size_t szie）返回值为 void*
new的重载还可以传参数  即加参数  但是不影响本身功能
new delete 一般作为成员函数存在
c++允许 全局的new和delete重载 但是几乎没有人使用

内存泄漏：申请了不释放
避免内存泄漏：养成良好编码规范与习惯
                        智能指针
                        泄漏检测工具

new delete 包含了 malloc 和 free  且 malloc 和 free 只是 new 和 delete 其中的步骤功能

继承：
在c++中 允许 将子类指针赋值给父类指针，但父类指针无法访问超出父类的本身
例：儿子:有 abcd  而父亲有ab  当子类给父类指针赋值后  父类指针只可以访问ab
因为 子类范围比父类范围大
 
隐藏：如果子类和父类有同名的变量和同类型的函数 虽然会被继承下来 但是会优先调用子类的
重写：虚函数被继承后，子类有同名同类型的函数，此时函数会被替换为子类的函数
           virtual 虚函数关键字
有虚函数就有虚表而虚函数在虚表里面当子类重写即在虚表里面重写了,当父类去调用的时候就是修改后的
虚函数只要有了，就会层层继承，一直继承一直重写

纯虚函数：就是虚函数等于0 例 virtual  void fun（） = 0；
包含纯虚函数的类叫抽象类
抽象类 不能定义对象 只能被继承
继承抽象类的子类 没有实现纯虚函数  就还是 抽象类
static成员的继承 不管继承多少次  static的成员永远只有一个全体共用
static函数只允许覆盖不能重写

继承多少层就会自动调用多少层默认构造函数  若父类没有默认构造 需要在当前父类的子类的默认构造函数的初始化列表进行初始化。
析构先自己后父类
