C++

同名的域在编译器会合并

全域引用外 还可以 部分引用  ::

**头文件**中不能全域引用 

局部引用 ：    using::成员

**class:**

一、

public:可访问可继承

protected:不可访问，可继承

private:不可    不可

二、

可以直接放函数； 函数不占用类的空间

###### **引用 &：起别名**

一：

必须初始化

1、实质：指针跨栈。

指针的作用：跨栈、访问堆。

2、引用可以作为函数返回值传回。

引用可以做左值



###### **函数重载：**

一、允许函数名一样，只要**函数参数列表不完全相同**，就可以同时存在。

**二、缺省参数**

void test(int a,int  b  =  5,int  c  = 0)；

b  c  为默认值，传值可改变默认值。

  **可缺省的参数 必须在参数列表的末尾**

问题： a=a^b 交换数值

多态  函数模板，模板类

**关键字：inline**

作用：

1、修饰一个函数，使其不创建新的栈。

2、建议的问题，当函数过于复杂，编译器会拒绝你的建议。



###### **运算符重载：**关键字：operator

###### 不能重载的运算符：

结构体取元素的“.”运算符、sizeof、条件？、域操作 ::、成员指针 .*  运算符。

operator new()只重载了**申请空间**和**报错**的功能，调用了构造函数。

operator delete 只重载了释放和报错的功能，析构函数不能调用。

C++允许全局的 new和delete。

new() 是允许传参的。

new  一般作为成员函数承载我自己的分配，全局是可以重载的(一般不用)。

### 

###### **友元**

 **7.30**

透传：

###### 闰年的个数 ：

起始和终止年份， 两端向下查找闰年，然后相减 / 4  = 闰年个数（自身是闰年还得往下找）

2021 ，2023

sy--,ey--;   //作用是包含2021年和2023年   2020  2022计算

 sy - = sy % 4;

ey -= ey % 4;

return  （ey - sy）/ 4

![1690789679982](C:\Users\孙一航\AppData\Roaming\Typora\typora-user-images\1690789679982.png)



###### 

**类和对象：**

构造函数：默认构造函数 没有参数

一般构造函数： 有参数

拷贝构造函数：参数只能是**自身类型的引用**，传入的必然是自身类型的引用

在构造函数的参数列表中，不**能出现自身类型的变量**；可以是指针和引用。 

**关键字**

###### **explicit ：**修饰构造函数，禁止构造函数的隐式转换。

(三)、析构函数语法：~类名(){}

- 析构函数，没有返回值也不写void

- 函数名称与类名相司,在名称前加上符号~
  析构西数不可以有参数，因此不可以发生重载
- 程序在对象销毀前会自动调用析构，无须手动调用,而且只会调用一次  

###### (四)、深拷贝与浅拷贝

- 浅拷贝：简单的赋值拷贝操作。  **带来的问题是：**堆区的内存重复释放 ，拷贝地址，重复析构一片堆区  ；
- 解决办法：自己实现拷贝构造函数 ，解决浅拷贝带来的问题。
- 深拷贝：在堆区重新申请空间，进行拷贝操作。
- 时拷贝(写时拷贝)：在赋值的时候不开辟空间，在该值的时候才会创建新的空间。释放：每片空间设置一个计数器（原空间计数器，新空间计数器） 然后析构。
- //析构(函数)代码，将 ‘堆区’ 开辟数据做释放操作
- ![1690772846294](C:\Users\孙一航\AppData\Roaming\Typora\typora-user-images\1690772846294.png)
- ![1690772789602](C:\Users\孙一航\AppData\Roaming\Typora\typora-user-images\1690772789602.png)

###### (五)、初始化列表

1、语法：构造函数（）：属性1（初值1），属性2（初值2）.....{函数实现体}
例子：Person(int a,int b) :ma(a),ma(b) {}

int ma,int mb;

传参
*//初始化列表可以告诉编译器调用那个构造函数

使用的情况：

1、引用成员   2、const成员变量   3、没有默认构造函数的对象。

系统会给自动提供：

默认构造函数、析构函数、默认前拷贝的拷贝构造函数、默认前拷贝的等号拷贝函数、取地址运算符的重载，const取地址的运算符重载。

规则：

- 如果自己实现了任何一个构造函数（除过拷贝构造），编译器不再提供任何默认构造函数。
- 拷贝指向同一片空间，析构会被析构两次（报错）；

###### **const调用：**

- const 对象不能调用 非const成员函数
- 非const对象可以调用 const成员函数
- 

![7628c4f02effca5adcc5605d58ebee7](C:\Users\孙一航\AppData\Local\Temp\WeChat Files\7628c4f02effca5adcc5605d58ebee7.png)

![ea3cf43272a96420598cc8e7facc74d](C:\Users\孙一航\AppData\Local\Temp\WeChat Files\ea3cf43272a96420598cc8e7facc74d.png)

######    strlen和sizeof区别：**

- strlen 是一个函数，它用来计算指定字符串 str 的长度，但不包括结束字符（即 null 字符）。
- 关键字 sizeof 是一个单目运算符，而不是一个函数。与函数 strlen 不同，它的参数可以是数组、指针、类型、对象、函数等

 

###### 构造函数调用原则：

- 如果用户定义有参构造函数，**不提供默认无参构造**，提供默认拷贝构造。
- 如果有定义拷贝构造函数，不提供其他构造函数。

init（）

**透传**



**friend**

friend ostream & operator<<( ostream& os,Test & t)  



ostream & operator<<( ostream& os,Test & t)

os<<t.m_a<<endl<<t.m_b<<endl;

输出流

istream & operator>>( istream& os,Test & t)

is>>t.m_a>>t.m_b;

输入流

**性质**

- 友元不具有相互性、传递性。

###### **静态成员：**

C语言作用：限定变量或函数的作用域。

限制了变量的定义域。  可以修饰局部变量，在栈上的全局区；定义在局部，作用在全局。

###### **静态成员变量特点**：

- 在编译阶段分配内存
- 类内声明，类外初始化            类型  类名 :: 声明 = 0；
- 所有对象**共享同一份静态成员变量数据**
- 可以直接通过类名调用

###### **静态成员函数特点：**

- 程序共享一个函数

- 静态成员函数只能访问静态成员变量

- 没有 this 指针
- 可以访问类内的私有  （传对象）
- 静态成员依然会受private 的限制无法访问。

##### **动态内存分配**

两个关键字 new  delete

释放数组  delete [] ;



###### **内部类：类的嵌套**

里面可以看见外面，外面看不到里面。



 []重载(访问其中一个元素)，用引用

引用就是变量本身？？？？

变量可以做左值，值不能做左值。



delete []val;

val = newval;

val 的内存被释放，释放旧的内存并将val指针重新指向新的内存(newval)的内存。



模板类：

返回引用，可以取地址返回引用，不能取地址，不能返回引用。

左值可以转换为引用类型   ？

const T&n = T（） ；将默认构造传给  n    T 是类型



非类型模板参数，只能传整型。



模板类不要用对应的文件 就在 hpp中写。

不在头文件中  namespace std；





### 如何避免内存泄漏

智能指针、养成良好的编码习惯，申请空间后记得 free、检查泄漏工具。

### malloc/free和new/delete的区别



### 继承

允许把子类指针指向(赋给)父类指针；反过来不行。

##### (一)、隐藏

如果子类和父类有同名变量，继承依然有效，只是继承出的子类会将父类中的同名变量覆盖。

##### (二)、重写、覆盖

父类的虚函数被继承后，子类如果有同名函数，此时函数会被替换成子类的函数。

虚函数 会被子类继承

##### (三)、纯虚函数和抽象类

纯虚函数，包含纯虚函数的类叫抽象类，没有实体；

抽象类包含纯虚函数的类，不能定义对象。

##### (四)、static成员继承

无论子类父类继承了多少个static a,  a永远只有一份共同体。

static不存在重写，只有覆盖。

### 构造，析构顺序

先构造父类，析构先析构子类再是父类。



### STL六大组件

容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。

![1691152640389](C:\Users\孙一航\AppData\Roaming\Typora\typora-user-images\1691152640389.png)



